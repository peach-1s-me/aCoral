# aCoral C语言代码规范


| 版本 | 作者           | 日期       | 更新内容         |
| ------ | ---------------- | ------------ | ------------------ |
| v0.1 | 饶洪江、文佳源 | 2025-03-18 | 增写目的、原则、命名 |
| v0.2 | 饶洪江、文佳源 | 2025-03-19 | v0.1修改、增写排版格式 |
| v0.3 | 饶洪江、文佳源 | 2025-03-20 | v0.2修改、增写注释、函数、头文件 |
| v1.0 | 饶洪江、文佳源 | 2025-03-21 | v0.3修改、完成本规范的基础版本 |
| v1.1 | 饶洪江、孟佳珉 | 2025-03-21 | v1.0基础版本的审查与修改 |

## <span id="goal">目的</span>

我们制定该规范的目的旨在提升代码质量、可维护性、协作效率、可移植性、安全性、可靠性，规范编码风格，确保代码清晰、易读、易维护，便于开发者理解和修改他人代码，便于知识传递。如果在团队运作中认为某个规则无法遵循，希望可以共同改进该规则。

## <span id="rule">原则</span>

代码需要在保证功能正确的前提下，满足规范的编码要求。

## <span id="1">1 命名</span>

命名包括文件、函数、变量、类型、宏等命名。

整体采用unix风格，即单词小写，用下划线分割， 如：`test_result`。

### <span id="1.1">1.1 标识符命名风格</span>


| 类型                                                                                     | 命名风格           |
| ------------------------------------------------------------------------------------------ | -------------------- |
| 函数，结构体类型，枚举类型，联合体类型变量，函数参数，宏参数，结构体中字段，联合体中成员 | 单词全小写，下划线分割 |
| 宏，常量，枚举值                                                                         | 单词全大写，下划线分割 |

**注意 1：** 对于单词的缩写，仅可使用约定俗成、被广泛使用的缩写，请勿随意自行进行缩写。不清楚该单词是否有惯用缩写时，使用完整单词。

**注意 2：** 与内核相关的函数名、类型、全局变量前需要加`acoral_`前缀。例：`acoral_ipc_sys_init`, `acoral_u8`, `acoral_ready_queues`

### <span id="1.2">1.2 文件命名</span>

文件名应尽量简短、准确、无二义性。

文件名命名只允许使用小写字母、数字以及下划线(_)。

好的命名举例：

`lwip_tcp_client.c`

### <span id="1.3">1.3 函数命名</span>

函数的命名遵循一般阅读习惯，动作类函数名，可以使用动宾或者主谓结构；

例：`acoral_mem_scan`, `acoral_get_ticks`

判断型函数，可以用形容词，或加 is。

例：`is_connected`, `data_ready`

### <span id="1.4">1.4 变量命名</span>

**除计数变量，所有变量命名均应该能够表达其含义、作用。**

变量命名使用unix风格，包括全局变量，局部变量，函数声明或定义中的参数，带括号宏中的参数。

与内核无关的全局变量需要增加`g_`前缀，与内核相关的全局变量需要增加`acoral_`前缀

函数局部变量的命名，在能够表达相关含义的前提下，应该尽量简短。

### <span id="1.5">1.5 类型命名</span>

定义结构体、联合体时均使用`typedef`，后缀加`_t`，且尽量使用匿名类型。左大括号需另起一行，右大括号与类型名间间隔一个空格。例：

```c
typedef struct
{
    acoral_u8 prio;优先级
    acoral_queue_t stack;局部资源系统栈
    acoral_queue_t wait;
} acoral_mpcp_system_t;

/* 特殊情况例外：必须加_acoral_mq_message */
typedef struct _acoral_mq_message
{
    struct _acoral_mq_message *next;
    acoral_size length;
} acoral_mq_message_t;
```

### <span id="1.6">1.6 宏、常量、枚举命名</span>

全大写，下划线分割

## <span id="2">2 排版格式</span>

### <span id="2.1">2.1 行宽</span>

行宽不能超过100个字符，不要在会导致内容截断的地方换行

### <span id="2.2">2.2 缩进</span>

使用空格进行缩进，每次缩进4个空格

### <span id="2.3">2.3 大括号</span>

除了<a href="#2.12">数组初始化</a>、<a href="#1.5">类型命名</a>、<a href="#2.7">循环中的`do-while`</a>外，所有左大括号和右大括号都另起一行放行首，并独占一行。

### <span id="2.4">2.4 函数声明与定义</span>

函数声明、定义的返回类型和函数名在同一行。

当行宽无法容纳所有参数或函数有3个及以上参数时，进行换行：

* 参数列表的左小括号总是和函数名在同一行，不要单独一行，且中间不要留空格；
* 其余参数缩进4个空格，并各自独占一行，以第一个非`*`字符对齐，参数类型与参数名间间距尽可能小；
* 右小括号另起一行放行首，并独占一行。

当函数无参数时，不能省略小括号中的`void`。

例：

```c
acoral_err acoral_mq_init(
    acoral_mq_t *mq, 
    void        *msg_buf, 
    acoral_size  buf_size, 
    acoral_size  msg_size
);

void buddy_scan(void);
```

### <span id="2.5">2.5 函数调用</span>

要么一行写完函数调用, 要么在小括号里对参数分行，函数调用时函数名与左小括号必须在同一行且中间无空格。

在对参数进行分行时，第一个参数紧跟在左小括号之后，其余参数各占独占一行并与第一个参数对齐；右小括号另起一行与左小括号对齐，并紧跟分号。例：

```c
    acoral_create_thread(period_func_9,
                         1024,
                         NULL,
                         "period_func_9",
                         NULL,
                         ACORAL_SCHED_POLICY_PERIOD,
                         &period_policy_data[7],
                         NULL,
                         NULL
                        );
```

如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。参数的格式处理应当以可读性而非其他作为最重要的原则。例：

```c
    matrix_transform(x1, x2, x3,
                     y1, y2, y3,
                     z1, z2, z3
                    );
```

### <span id="2.6">2.6 条件语句</span>

条件语句必须要使用大括号，大括号的格式按照<a href="#2.3">2.3</a>。

`if`和左小括号间留一个空格。

```c
    if (condition)
    {
        /* code */
    }
```

使用==判断时，将常量放于==左边，使用其他判断符时，变量放于左边。（循环中的判断也须遵循）

### <span id="2.7">2.7 循环</span>

与条件语句类似循环体中仅有一条时，也必须要使用大括号，大括号的格式按照<a href="#2.3">2.3</a>。

`while`、`for`和左小括号间留一个空格。例：

```c
    while (condition)
    {
        /* code */
    }
```

但如果循环体为空，则不要使用大括号，在右小括号后紧跟`;`。例：

```c
    while(1);
```

例外，`do-while`的括号风格如下：

```c
    do {
        /* code */
    } while(condition);
```
### <span id="2.8">2.8 switch语句</span>

switch 语句的 case/default 要缩进一层。`switch`和左小括号间留一个空格，`switch`和条件间留一个空格。例：

```c
    switch (buf->time_unit)
    {
        case TIME_UNIT_US:
        {
            during *= 1000;
            break;
        }
        case TIME_UNIT_MS:
        {
            break;
        }
        default:
        {
            acoral_print("ERROR: unknown time unit\r\n");
            break;
        }
    }
```

switch语句中必须要有default分支，保证在遗漏case标签处理时能够有一个缺省的处理行为。
### <span id="2.10">2.10 表达式</span>
较长的表达式，不满足行宽要求的时候，一般在较低优先级操作符或连接符后面截断，操作符或连接符放在行末，以表示“未结束，后续还有”。

换行后保持对齐。例：
```c
    int sum = long_variable_name_1 + long_variable_name2 + long_variable_name_3 +
              long_variable_name_4 + variable_name5 + variable_name_6;  
```
### <span id="2.11">2.11 变量赋值</span>
每行只有一个变量初始化的语句，更容易阅读和理解。

对于多个相关性强的变量定义，且无需初始化时，可以定义在一行，减少重复信息，以便代码更加紧凑。例：
```c
int point_x, point_y;
int point_count = 0;
```
### <span id="2.12">2.12 初始化</span>
初始化包括结构体、联合体及数组的初始化。结构体或数组初始化时，如果需要换行应在左大括号后开始换行并保持4空格缩进。例：
```c
    int arr[4] = { 1, 2, 3, 4 };
    const int rank[] = { 
        16, 16, 16, 16, 32, 32, 32, 32,
        64, 64, 64, 64, 32, 32, 32, 32
    };
    int array[][4] = {
        { 1, 2, 3, 4 }, { 2, 2, 3, 4 }, /* OK */
        { 3, 2, 3, 4 }, { 4, 2, 3, 4 }
    };
    
    /* 指定初始化，每个成员的初始化单独一行 */
    typedef struct
    {
        int year;
        int month;
        int day;
    } date_t;

    date_t date = {    
        .year   = 2000,
        .month  = 1,
        .day    = 1 
    };
```
### <span id="2.13">2.13 指针</span>
指针类型`*`跟随变量名，`*`前留有空格；若存在无法跟随的情况时时就不跟随。例：
```c
    int *ptr;

    /* 无法跟随 */
    char * const VERSION = "V100";
    int foo(const char * restrict ptr);
```
**注意**：任何时候 `*` 不要紧跟 const 或 restrict 关键字。

### <span id="2.14">2.14 编译预处理</span>
编译预处理的"#"放在行首，嵌套编译预处理语句时，"#"不进行缩进，但需要在`#enfif`、`#else`、`#elif`处注释以标明其对应哪个`#if`。例：
```c
#if condition_1

#if condition_2

#elif condition_3 /* if  condition_2 */

#else  /* if  condition_3 */

#endif /* if condition_2 */

#endif /* if condition_1 */
```
### <span id="2.15">2.15 空格和空行</span>
水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。 总体规则如下：

* if, switch, case, do, while, for 等关键字之后加空格；
* 小括号内部的两侧，不要加空格
* 二元操作符（= + ‐ < > * / % | & ^ <= >= == !=）左右两侧加空格
* 一元操作符（& * + ‐ ~ !）之后不要加空格
* 三目操作符（? :）符号两侧均需要空格
* 结构体中表示位域的冒号，两侧均需要空格
* 前置和后置的自增、自减（++ --）和变量之间不加空格
* 结构体成员操作符（. ->）前后不加空格
* 逗号、分号、冒号（不含三目操作符和表示位域的冒号）紧跟前面内容无空格，其后需要空格
* 函数参数列表的小括号与函数名之间无空格
* 类型强制转换的小括号与被转换对象之间无空格
* 数组的中括号与数组名之间无空格
* 涉及到换行时，行末的空格可以省去

对于大括号内部两侧的空格，要求如下：

* 一般的，大括号内部两侧建议加空格
* 对于空的，或单个标识符，或单个字面常量，不加空格。

例：
```c
    int buf[BUF_SIZE] = {0};
    int arr[] = { 10, 20 };
```

按上下内容的相关程度安排空行，并保持代码紧凑，方便代码阅读。

* 根据上下内容的相关程度，合理安排空行；
* 函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行
* 不使用连续3个空行或更多
* 大括号内的代码块首行之前和末行之后不要加空行。

## <span id="3">3 注释</span>

### <span id="3.1">3.1 文件头注释</span>
文件头按以下格式进行注释
```c
/**
 * @file ipc.c
 * @author 胡博文 (@921576434@qq.com)
 * @brief kernel层线程通信相关源文件
 * @version 1.3
 * @date 2025-03-17
 * 
 * @copyright Copyright (c) 2022 EIC-UESTC
 * 
 * @par 修订历史
 *     <table>
 *         <tr><th>版本 <th>作者 <th>日期 <th>修改内容
 *         <tr><td>v1.0 <td>胡博文 <td>2022-07-13 <td>增加注释
 *         <tr><td>v1.1 <td>胡博文 <td>2022-09-26 <td>错误头文件相关改动
 *         <tr><td>v1.2 <td>文佳源 <td>2025-02-26 <td>修改acoral_ipc_wait_queue_empty返回值类型bool->acoral_bool
 *         <tr><td>v1.3 <td>饶洪江 <td>2025-03-17 <td>增加消息队列
 */
```
### <span id="3.2">3.2 函数头注释</span>

所有函数都需要函数头注释。函数头注释统一放在函数定义上方。注释内容为主要为功能描述，必要时可以添加注意事项。

使用如下格式进行注释，参数说明对齐:

```c
/**
 * @brief 通用线程初始化
 * 
 * @param thread 线程tcb指针
 * @param route  线程运行函数
 * @param exit   线程退出函数
 * @param args   传递参数
 * @return acoral_err 错误检测
 */
acoral_err acoral_thread_init(
    acoral_thread_t *thread,
    void           (*route)(void *args),
    void           (*exit)(void),
    void            *args
)
```
无参数时则无需`@param`，范围类型为`void`时则无需`@return`：
```c
/**
 * @brief 伙伴系统扫描，查看是否有空闲块
 * 
 */
void buddy_scan(void)
```
### <span id="3.4">3.4 代码注释</span>
代码注释统一使用`/*` `*/`，`*`与注释内容隔一个空格:
```c
/* 内容 */

/**
 * 内容...
 * 内容...
 */
```
代码右边的注释，与代码之间，留1空格。
相邻很近的右置注释，请保持上下对齐。

`case`语句块结束时如果不加break/return，需要有注释说明"fall-through"

临时注释的代码在push到项目前必须删除。
## <span id="4">4 头文件</span>
### <span id="4.1">4.1 头文件职责</span>
* 头文件是模块或文件的对外接口。
* 头文件中适合放置接口的声明，不允许放置实现（内联函数除外）。
* 头文件应当职责单一。

除非一个.c文件不需要对外公布任何接口，否则每个.c文件都有一个相应的.h（尽量同名），用于放置对外提供的函数声明、宏定义、类型定义等。

内部使用的函数声明，宏、枚举、结构体等定义不应放在头文件中。

### <span id="4.2">4.2 头文件依赖</span>
**禁止头文件循环依赖**：禁止 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h等类似情况。

禁止通过声明的方式引用外部函数接口、变量，只能通过包含头文件的方式使用其他模块或文件提供的接口、变量（即在.h中extern 变量）。

### <span id="4.3">4.3 头文件保护</span>
为防止头文件被多重包含，所有头文件都应当使用 #define 作为包含保护，不要使用 #pragma once

保护符使用唯一名称；统一使用从项目根目录开始的目录名_..._文件名定_H命名（省略掉include或inc）。例：

```c
#ifndef KERNEL_BITOPS_H
#define KERNEL_BITOPS_H

#endif
```

## <span id="5">5 函数</span>
一个函数只完成一件事情，函数应该尽量简洁、短小。
### <span id="5.1">5.1 函数设计</span>
避免函数过长，函数尽量不超过80行（非空非注释）。函数长度过长时，需要考虑进一步抽象，并编写额外的函数；进一步抽象会明显降低可读性时，也可保持原长度。

避免函数的代码控制块（例如：`if`、`for`、`while`、`switch`等）之间嵌套过深，尽量不要超过4层。

对函数的错误返回码要进行处理：
```c
    err = acoral_thread_init(...);
    if (err != KR_OK)
    {
        acoral_printerr("No thread stack:%s\n",thread->name);
        ...
        return err;
    }
```
### <span id="5.2">5.2 函数参数</span>
* 优先使用返回值而不是输出参数
* 设计函数的参数时，统一按输入、输出、出入的顺序定义参数。
* 设计函数的资源时，涉及内存、锁、队列等资源分配的，需要同时提供释放函数。
* 对于模块外部传入的参数，必须进行合法性检查，保护程序免遭非法输入数据的破坏；模块内部函数调用，由调用者负责保证参数检测
```c
    /* 参数检测 */
    if(mq->msg_queue_ipc->type != ACORAL_IPC_MQ)
    {
        return KR_IPC_ERR_TYPE;
    }
```
* 函数的指针参数如果不是用于修改所指向的对象就应该声明为指向const的指针。
```c
/* 不变参数声明为const */
int strncmp(const char *s1, const char *s2, size_t n);
```
### <span id="5.3">5.3 内联函数</span>

内联函数规模建议控制在 10 行以内（非空非注释）。

被多个源文件调用的内联函数要放在头文件中定义。

## <span id="6">6 宏</span>
### <span id="6.1">6.1 函数式宏的括号使用</span>
定义函数式宏时，宏参数要使用完备的括号，具体如下：
```c
/* 100 / SUM(2, 8)将扩展成(100 / 2) + 8，预期结果则是100 / (2 + 8) */
#define SUM(a, b) a + b
/* SUM(1 << 2, 8)扩展成1 << (2 + 8)（因为`<<`优先级低于`+`），跟预期结果(1 << 2) + 8不符 */
#define SUM(a, b) (a + b)
/* SUM(2, 8) * 10扩展后的结果为(2) + ((8) * 10)，跟预期结果(2 + 8) * 10不符 */
#define SUM(a, b) (a) + (b)

/* 正确写法：括号完备 */
#define SUM(a, b) ((a) + (b))
```
但是要避免滥用括号:
* 单独的数字（负数要加）或标识符加括号毫无意义
* 宏参数参与 '#', '##' 操作时，不要加括号
* 宏参数参与字符串拼接时，不要加括号
* 宏参数作为独立部分，在赋值（包括+=, -=等）操作的某一边时，无需括号
```c
#define SOME_CONST      100  /* 单独的数字无需括号 */
#define ANOTHER_CONST   (-1) /* 负数需要使用括号 */

#define THE_CONST SOME_CONST /* 单独的标识符无需括号 */

#define MAKE_STR(x) #x               /* x 不要加括号 */
#define HELLO_STR(obj) "Hello, " obj /* obj 不要加括号 */

#define ADD_3(sum, a, b, c) (sum = (a) + (b) + (c)) /* a, b, c 需要括号；而 sum 无需括号 */
```
### <span id="6.2">6.2 多行函数式宏</span>
函数式宏不超过10行(非空非注释)，同时注意保持`\`的对齐

包含多条语句的函数式宏的实现语句必须放在 `do-while(0)`:
```c
#define FUNC(x)                           \
    do {                                  \
        (void)printf("arg is %d\n", (x)); \
        do_something((x));                \
    } while (0)
```
* 包含 break, continue 语句的宏可以例外。使用此类宏务必特别小心。
* 宏中包含不完整语句时，可以例外。比如用宏封装 for 循环的条件部分。

### <span id="6.3">6.3 函数宏式的其他规则</span>

函数式宏的参数大于等于3时可不按照函数的方式处理，分段时合理且不影响可读性即可

```c
#define acoral_create_thread(route, stack_size, args, name, \
                             stack, policy, policy_data, data, hook) \
    create_thread_by_policy(route, stack_size, args, name, \
                            stack, policy, policy_data, data, hook);
```

不允许把带副作用的表达式，如`num++`，作为参数传递给函数式宏。

不允许把函数调用作为参数传递给函数式宏。

函数式宏定义中慎用return、continue、break等改变程序流程的语句，若要使用，在宏命名时务必要体现对应关键字以及其作用：
```c

#define LOG_AND_RETURN_IF_FAIL(ret, fmt, ...) \
    do {                                      \
        if ((ret) != OK) {                    \
            (void)ErrLog(fmt, ##__VA_ARGS__); \
            return (ret);                     \
        }                                     \
    } while (0)
```
## <span id="7">7 变量</span>
### <span id="7.1">7.1 全局变量</span>
尽量少的使用全局变量。

全局变量是模块内部的具体实现，不推荐但允许跨文件使用，但禁止作为模块接口暴露出去；如果本模块的数据需要对外部模块开放，应提供对应函数接口。

### <span id="7.2">7.2 局部变量</span>

严禁使用未经初始化的变量（指局部动态变量，并且还包括内存堆上申请的内存块）。

如果有不同分支，要确保所有分支都得到初始化后才能使用：

```c
void func(...)
{
    int data;
    if (...)
    {
        data = 100;
    }
    do_something(data); /* 错误：部分分支该值未初始化 */
    ...
}
```
禁止无效、冗余的变量初始化，如果没有确定的初始值，不要进行初始化，否则可能掩盖更大的问题。

冗余初始化，可能会影响到性能：

```c
char buf[VERY_BIG_SIZE] = {0};  
memset(buf, 0, sizeof(buf)); /* 冗余清零 */
```

下面的代码，如果没有赋 0 初始化，静态检查工具可以帮助发现“未经初始化就直接使用”的问题。但因为无效初始化，“使用数据”与“获取数据”写颠倒的缺陷，不能被轻易发现。

```c
void func(...)
{
    int data = 0; /* 错误: 习惯性的无意义初始化 */

    do_something(data);   /* 使用数据，本应该写在获取数据后面 */
    data = get_data(...); /* 获取数据 */
    ...
}
```
不允许使用看不懂、难以理解的数字，如：`type = 2`、`status = 3`等。

正确处理：
对于单点使用的数字，可以增加注释说明；对于多处使用的数字，必须定义宏或const 变量，并通过符号命名自注释。
例：
```c
/* ipc类型：互斥量 */
#define ACORAL_IPC_MUTEX 0
```
## <span id="8">8 编程过程中的其他规则</span>
### <span id="8.1">8.1 变量自增或自减运算</span>
含有变量自增或自减运算的表达式中，如果再引用该变量，其结果在C标准中未明确定义，故禁止该行为。例：

```c
/* 错误写法 */
sum = arr[i] + i++;

/* 正确写法 */
sum = arr[i] + i;
i++;
```
### <span id="8.2">8.2 使用括号明确表达式操作顺序</span>
可以使用括号强调表达式操作顺序，但过多的括号会分散代码使其降低了可读性，应适度使用。

当表达式包含不常用，优先级易混淆的操作符时，使用括号，比如位操作符。

### <span id="8.3">8.3 禁止使用`goto`语句</span>

`goto`语句会破坏程序的结构性，本规范禁止使用`goto`语句。

### <span id="8.4">8.4 使用强制类型转换代替默认类型转换</span>

发生默认类型转换时，均替换为使用强制类型转换进行显式的类型转换。